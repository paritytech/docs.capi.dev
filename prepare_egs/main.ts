import * as fs from "https://deno.land/std@0.185.0/fs/mod.ts"
import * as path from "https://deno.land/std@0.185.0/path/mod.ts"
import { description, title, toMarkdown } from "https://deno.land/x/egts@v0.1.0-beta.3/mod.ts"

const clonePath = new URL("capi", import.meta.url)
try {
  await Deno.remove(clonePath, { recursive: true })
  // deno-lint-ignore no-empty
} catch (_) {}
await Deno.mkdir(clonePath)
await new Deno.Command("git", {
  args: ["init"],
  cwd: clonePath,
}).output()
await new Deno.Command("git", {
  args: ["remote", "add", "-f", "origin", "git@github.com:paritytech/capi.git"],
  cwd: clonePath,
}).output()
await new Deno.Command("git", {
  args: ["config", "core.sparseCheckout", "true"],
  cwd: clonePath,
}).spawn().output()
await Deno.writeTextFile(path.join(clonePath.pathname, ".git/info/sparse-checkout"), "examples/")
await new Deno.Command("git", {
  args: ["pull", "origin", "main"],
  cwd: clonePath,
}).spawn().output()

const examplesDir = path.join(clonePath.pathname, "examples")
const exampleMdsDir = new URL("../docs/examples/", import.meta.url).pathname
await fs.emptyDir(exampleMdsDir)
const pending: Promise<void>[] = []
for await (const walkEntry of fs.walk(examplesDir)) {
  if (walkEntry.isFile && walkEntry.path.endsWith(".eg.ts")) {
    const pathname = walkEntry.path
    const relativePathWithoutExt = path.relative(examplesDir, pathname).slice(0, -6)
    const dest = `${exampleMdsDir}/${relativePathWithoutExt}.md`
    pending.push((async () => {
      const src = await Deno.readTextFile(pathname)
      const { frontmatter, content: contentRaw } = toMarkdown(pathname, src, {
        title,
        description,
      })
      const content = `<!-- generated by \`generate/main.ts\ -->
# ${frontmatter.title}

${frontmatter.description}

---

${contentRaw}`
      await fs.ensureFile(dest)
      await Deno.writeTextFile(dest, content)
    })())
  }
}
await Promise.all(pending)
await new Deno.Command("dprint", { args: ["."] }).output()
