"use strict";(self.webpackChunkdocs_capi_dev_2=self.webpackChunkdocs_capi_dev_2||[]).push([[275],{3905:(n,e,a)=>{a.d(e,{Zo:()=>l,kt:()=>d});var t=a(7294);function o(n,e,a){return e in n?Object.defineProperty(n,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):n[e]=a,n}function s(n,e){var a=Object.keys(n);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(n);e&&(t=t.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),a.push.apply(a,t)}return a}function r(n){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?s(Object(a),!0).forEach((function(e){o(n,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(a,e))}))}return n}function i(n,e){if(null==n)return{};var a,t,o=function(n,e){if(null==n)return{};var a,t,o={},s=Object.keys(n);for(t=0;t<s.length;t++)a=s[t],e.indexOf(a)>=0||(o[a]=n[a]);return o}(n,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);for(t=0;t<s.length;t++)a=s[t],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(n,a)&&(o[a]=n[a])}return o}var c=t.createContext({}),b=function(n){var e=t.useContext(c),a=e;return n&&(a="function"==typeof n?n(e):r(r({},e),n)),a},l=function(n){var e=b(n.components);return t.createElement(c.Provider,{value:e},n.children)},u="mdxType",p={inlineCode:"code",wrapper:function(n){var e=n.children;return t.createElement(t.Fragment,{},e)}},m=t.forwardRef((function(n,e){var a=n.components,o=n.mdxType,s=n.originalType,c=n.parentName,l=i(n,["components","mdxType","originalType","parentName"]),u=b(a),m=o,d=u["".concat(c,".").concat(m)]||u[m]||p[m]||s;return a?t.createElement(d,r(r({ref:e},l),{},{components:a})):t.createElement(d,r({ref:e},l))}));function d(n,e){var a=arguments,o=e&&e.mdxType;if("string"==typeof n||o){var s=a.length,r=new Array(s);r[0]=m;var i={};for(var c in e)hasOwnProperty.call(e,c)&&(i[c]=e[c]);i.originalType=n,i[u]="string"==typeof n?n:o,r[1]=i;for(var b=2;b<s;b++)r[b]=a[b];return t.createElement.apply(null,r)}return t.createElement.apply(null,a)}m.displayName="MDXCreateElement"},6512:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>b});var t=a(7462),o=(a(7294),a(3905));const s={},r="Runes vs Observables",i={unversionedId:"rune/advanced/runes-vs-observables",id:"rune/advanced/runes-vs-observables",title:"Runes vs Observables",description:"Runes of a Feather Update Together",source:"@site/docs/rune/advanced/runes-vs-observables.md",sourceDirName:"rune/advanced",slug:"/rune/advanced/runes-vs-observables",permalink:"/rune/advanced/runes-vs-observables",draft:!1,editUrl:"https://github.com/paritytech/docs.capi.dev/tree/main/docs/rune/advanced/runes-vs-observables.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Custom Rune Logic",permalink:"/rune/advanced/custom-runes"},next:{title:"FAQ",permalink:"/faq/"}},c={},b=[{value:"Runes of a Feather Update Together",id:"runes-of-a-feather-update-together",level:2}],l={toc:b},u="wrapper";function p(n){let{components:e,...a}=n;return(0,o.kt)(u,(0,t.Z)({},l,a,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"runes-vs-observables"},"Runes vs Observables"),(0,o.kt)("h2",{id:"runes-of-a-feather-update-together"},"Runes of a Feather Update Together"),(0,o.kt)("p",null,"Runes are similar to RxJS-style observables, in that they are lazy collections\nof multiple values. However, there is an important difference between runes and\nobservables \u2013 namely, that runes maintain ",(0,o.kt)("a",{parentName:"p",href:"/rune/advanced/timing"},"consistency"),"\nby retaining information about the sources of updates. This is perhaps best\nillustrated by a series of examples."),(0,o.kt)("p",null,"First, let's look at a derived query based on one event source in both RxJS and\nRune."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'/* RxJS */\n\nimport { concatMap, delay, map, of, timer, zip } from "npm:rxjs"\n\n// Some kind of event source; this might correspond to, say, new blocks from a given chain\nconst a = timer(0, 1000).pipe(map((n) => `a${n}`)) // a0, a1, a2, ...\n\n// Two different derived asynchronous queries based off of `a`\nconst ax = a.pipe(concatMap((value) => of(`${value}.x`).pipe(delay(500)))) // a0.x, a1.x, a2.x, ...\nconst ay = a.pipe(concatMap((value) => of(`${value}.y`).pipe(delay(250)))) // a0.y, a1.y, a2.y, ...\n\n// Combine the results from each to process in some way\nconst az = zip(ax, ay)\n\nconst start = Date.now()\naz.subscribe((value) => {\n  console.log(Date.now() - start, value)\n})\n\n// Every update is based on only one value from `a`; this is good.\n/*\n  506 [ "a0.x", "a0.y" ]\n  1505 [ "a1.x", "a1.y" ]\n  2507 [ "a2.x", "a2.y" ]\n  3510 [ "a3.x", "a3.y" ]\n  4511 [ "a4.x", "a4.y" ]\n  ...\n*/\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'/* Rune */\n\nimport { Rune } from "capi"\nimport { delay } from "https://deno.land/std@0.127.0/async/mod.ts"\n\n// Some kind of event source; this might correspond to, say, new blocks from a given chain\nconst a = timer(1000).map((n) => `a${n}`) // a0, a1, a2, ...\n\n// Two different derived asynchronous queries based off of `a`\nconst ax = a.map((value) => delay(500).then(() => `${value}.x`)) // a0.x, a1.x, a2.x, ...\nconst ay = a.map((value) => delay(500).then(() => `${value}.y`)) // a0.y, a1.y, a2.y, ...\n\n// Combine the results from each to process in some way\nconst az = Rune.tuple([ax, ay])\n\nconst start = Date.now()\nfor await (const value of az.iter()) {\n  console.log(Date.now() - start, value)\n}\n\n// Every update is based on only one value from `a`; this is good.\n/*\n  503 [ "a0.x", "a0.y" ]\n  1505 [ "a1.x", "a1.y" ]\n  2507 [ "a2.x", "a2.y" ]\n  3509 [ "a3.x", "a3.y" ]\n  4512 [ "a4.x", "a4.y" ]\n  ...\n*/\n\nfunction timer(ms: number) {\n  return Rune.asyncIter(async function*() {\n    let i = 0\n    while (true) {\n      yield i++\n      await delay(ms)\n    }\n  })\n}\n')),(0,o.kt)("p",null,"So far, RxJS and Rune behave equivalently. Now, let's look at what happens once\nwe have multiple event sources:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'/* RxJS */\n\nimport { combineLatest, map, timer, zip } from "npm:rxjs"\n\n// Two event sources with different speeds\nconst a = timer(0, 1000).pipe(map((n) => `a${n}`)) // a0, a1, a2, ...\nconst b = timer(0, 1500).pipe(map((n) => `b${n}`)) // b0, b1, b2, ...\n\n// Combine them with `zip` like before\nconst ab1 = zip(a, b)\n\nconst start1 = Date.now()\nab1.subscribe((value) => {\n  console.log(Date.now() - start1, value)\n})\n\n// Every update has the same index of both `a` and `b`, but this shouldn\'t be\n// the case, since `b` is slower than `a`.\n/*\n  3 [ "a0", "b0" ]\n  1505 [ "a1", "b1" ]\n  3006 [ "a2", "b2" ]\n  4507 [ "a3", "b3" ]\n  6009 [ "a4", "b4" ]\n  7511 [ "a5", "b5" ]\n  9017 [ "a6", "b6" ] // should be at `a9` but this lags behind\n  ...\n*/\n\n// Instead, we want to combine them using `combineLatest`:\nconst ab2 = combineLatest([a, b])\n\nconst start2 = Date.now()\nab2.subscribe((value) => {\n  console.log(Date.now() - start2, value)\n})\n\n// This is what we want:\n/*\n  4 [ "a0", "b0" ]\n  1004 [ "a1", "b0" ]\n  1507 [ "a1", "b1" ]\n  2005 [ "a2", "b1" ]\n  3008 [ "a3", "b1" ]\n  3009 [ "a3", "b2" ]\n  4009 [ "a4", "b2" ]\n  4511 [ "a4", "b3" ]\n  5012 [ "a5", "b3" ]\n  6013 [ "a5", "b4" ]\n  6013 [ "a6", "b4" ]\n  7015 [ "a7", "b4" ]\n  7517 [ "a7", "b5" ]\n  8023 [ "a8", "b5" ]\n  9024 [ "a8", "b6" ]\n  9024 [ "a9", "b6" ] // both up-to-date\n  ...\n*/\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'/* Rune */\n\nimport { Rune } from "capi"\nimport { delay } from "https://deno.land/std@0.127.0/async/mod.ts"\n\nconst a = timer(1000).map((n) => `a${n}`) // a0, a1, a2, ...\nconst b = timer(1500).map((n) => `b${n}`) // b0, b1, b2, ...\n\n// Combine them with `ls` like before:\nconst ab = Rune.tuple([a, b])\n\nconst start = Date.now()\nfor await (const value of ab.iter()) {\n  console.log(Date.now() - start, value)\n}\n\n// This still has the correct behavior, without having to change the combinator:\n/*\n  2 [ "a0", "b0" ]\n  1003 [ "a1", "b0" ]\n  1506 [ "a1", "b1" ]\n  2005 [ "a2", "b1" ]\n  3007 [ "a3", "b1" ]\n  3007 [ "a3", "b2" ]\n  4009 [ "a4", "b2" ]\n  4509 [ "a4", "b3" ]\n  5010 [ "a5", "b3" ]\n  6011 [ "a5", "b4" ]\n  6012 [ "a6", "b4" ]\n  7013 [ "a7", "b4" ]\n  7514 [ "a7", "b5" ]\n  8021 [ "a8", "b5" ]\n  9020 [ "a8", "b6" ]\n  9023 [ "a9", "b6" ] // both up-to-date\n*/\n')),(0,o.kt)("p",null,"We can still achieve the same behavior in both, but in RxJS, we had to use a\ndifferent combinator. (",(0,o.kt)("inlineCode",{parentName:"p"},"combineLatest")," wouldn't have worked in the first example\nas it would've given ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," inconsistent values)."),(0,o.kt)("p",null,"As the timing gets even more complex, though, it becomes infeasible to handle\ncorrectly in RxJS:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'/* RxJS */\n\nimport { combineLatest, map, timer, zip } from "npm:rxjs"\n\nconst a = timer(0, 1000).pipe(map((n) => `a${n}`)) // a0, a1, a2, ...\nconst b = timer(0, 1500).pipe(map((n) => `b${n}`)) // b0, b1, b2, ...\nconst c = timer(0, 2500).pipe(map((n) => `c${n}`)) // c0, c1, c2, ...\n\n// From our above experiments we know that this needs to be `combineLatest`\nconst ab = combineLatest([a, b])\nconst bc = combineLatest([b, c])\n\n// But what should this be?\nconst allTogetherNow1 = zip(ab, bc)\n\nconst start1 = Date.now()\nallTogetherNow1.subscribe((value) => {\n  console.log(Date.now() - start1, value)\n})\n\n// Again, `zip` makes some of these lag. In this case, it also gives b inconsistent values.\n/*\n  3 [ [ "a0", "b0" ], [ "b0", "c0" ] ]\n  1504 [ [ "a1", "b0" ], [ "b1", "c0" ] ] // b has inconsistent values\n  2506 [ [ "a1", "b1" ], [ "b1", "c1" ] ]\n  3007 [ [ "a2", "b1" ], [ "b2", "c1" ] ] // again\n  4509 [ [ "a2", "b2" ], [ "b3", "c1" ] ]\n  5008 [ [ "a3", "b2" ], [ "b3", "c2" ] ]\n  6011 [ [ "a4", "b2" ], [ "b4", "c2" ] ] // now it\'s inconsistent by 2 ticks\n  7510 [ [ "a4", "b3" ], [ "b4", "c3" ] ]\n  7512 [ [ "a5", "b3" ], [ "b5", "c3" ] ]\n  9016 [ [ "a5", "b4" ], [ "b6", "c3" ] ] // a should be at 9\n*/\n\n// Alternatively, would could use `combineLatest`...\nconst allTogetherNow2 = combineLatest([ab, bc])\n\nconst start2 = Date.now()\nallTogetherNow2.subscribe((value) => {\n  console.log(Date.now() - start2, value)\n})\n\nconst start2 = Date.now()\nab2.subscribe((value) => {\n  console.log(Date.now() - start2, value)\n})\n\n// But now even though they all have the right speed, b still has inconsistent values\n/*\n  3 [ [ "a0", "b0" ], [ "b0", "c0" ] ]\n  1006 [ [ "a1", "b0" ], [ "b0", "c0" ] ]\n  1505 [ [ "a1", "b1" ], [ "b0", "c0" ] ] // b has inconsistent values\n  1506 [ [ "a1", "b1" ], [ "b1", "c0" ] ]\n  2008 [ [ "a2", "b1" ], [ "b1", "c0" ] ]\n  2506 [ [ "a2", "b1" ], [ "b1", "c1" ] ]\n  3007 [ [ "a2", "b2" ], [ "b1", "c1" ] ] // another inconsistency\n  3007 [ [ "a2", "b2" ], [ "b2", "c1" ] ]\n  3010 [ [ "a3", "b2" ], [ "b2", "c1" ] ]\n  4012 [ [ "a4", "b2" ], [ "b2", "c1" ] ]\n  4510 [ [ "a4", "b3" ], [ "b2", "c1" ] ] // and another\n  4510 [ [ "a4", "b3" ], [ "b3", "c1" ] ]\n  5007 [ [ "a4", "b3" ], [ "b3", "c2" ] ]\n  5014 [ [ "a5", "b3" ], [ "b3", "c2" ] ]\n  6013 [ [ "a5", "b4" ], [ "b3", "c2" ] ] // etc.\n  6013 [ [ "a5", "b4" ], [ "b4", "c2" ] ]\n  6015 [ [ "a6", "b4" ], [ "b4", "c2" ] ]\n  7017 [ [ "a7", "b4" ], [ "b4", "c2" ] ]\n  7509 [ [ "a7", "b4" ], [ "b4", "c3" ] ]\n  7514 [ [ "a7", "b5" ], [ "b4", "c3" ] ]\n  7514 [ [ "a7", "b5" ], [ "b5", "c3" ] ]\n  8025 [ [ "a8", "b5" ], [ "b5", "c3" ] ]\n  9022 [ [ "a8", "b6" ], [ "b5", "c3" ] ]\n  9022 [ [ "a8", "b6" ], [ "b6", "c3" ] ]\n  9027 [ [ "a9", "b6" ], [ "b6", "c3" ] ]\n  ...\n*/\n')),(0,o.kt)("p",null,"No RxJS combinator will work in this case because the updates need to be handled\ndifferently depending on it it's ",(0,o.kt)("inlineCode",{parentName:"p"},"b")," updating (in which case it should be like\n",(0,o.kt)("inlineCode",{parentName:"p"},"zip"),") or ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"c")," updating (in which case it should be like ",(0,o.kt)("inlineCode",{parentName:"p"},"combineLatest"),")."),(0,o.kt)("p",null,"However, this works implicitly in rune:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'/* Rune */\n\nimport { Rune } from "capi"\nimport { delay } from "https://deno.land/std@0.127.0/async/mod.ts"\n\nconst a = timer(1000).map((n) => `a${n}`) // a0, a1, a2, ...\nconst b = timer(1500).map((n) => `b${n}`) // b0, b1, b2, ...\nconst c = timer(2500).map((n) => `c${n}`) // c0, c1, c2, ...\n\nconst ab = Rune.tuple([a, b])\nconst bc = Rune.tuple([b, c])\n\n// The combinator is the same as always\nconst allTogetherNow = Rune.tuple([ab, bc])\n\nconst start = Date.now()\nfor await (const value of allTogetherNow.iter()) {\n  console.log(Date.now() - start, value)\n}\n\n// And everything works correctly; `a` is faster than `b` is faster than `c`,\n// and `b`\'s value is always consistent:\n/*\n  2 [ [ "a0", "b0" ], [ "b0", "c0" ] ]\n  1004 [ [ "a1", "b0" ], [ "b0", "c0" ] ]\n  1504 [ [ "a1", "b1" ], [ "b1", "c0" ] ]\n  2005 [ [ "a2", "b1" ], [ "b1", "c0" ] ]\n  2502 [ [ "a2", "b1" ], [ "b1", "c1" ] ]\n  3005 [ [ "a2", "b2" ], [ "b2", "c1" ] ]\n  3007 [ [ "a3", "b2" ], [ "b2", "c1" ] ]\n  4008 [ [ "a4", "b2" ], [ "b2", "c1" ] ]\n  4508 [ [ "a4", "b3" ], [ "b3", "c1" ] ]\n  5005 [ [ "a4", "b3" ], [ "b3", "c2" ] ]\n  5009 [ [ "a5", "b3" ], [ "b3", "c2" ] ]\n  6009 [ [ "a5", "b4" ], [ "b4", "c2" ] ]\n  6011 [ [ "a6", "b4" ], [ "b4", "c2" ] ]\n  7013 [ [ "a7", "b4" ], [ "b4", "c2" ] ]\n  7508 [ [ "a7", "b4" ], [ "b4", "c3" ] ]\n  7510 [ [ "a7", "b5" ], [ "b5", "c3" ] ]\n  8013 [ [ "a8", "b5" ], [ "b5", "c3" ] ]\n  9013 [ [ "a8", "b6" ], [ "b6", "c3" ] ]\n  9014 [ [ "a9", "b6" ], [ "b6", "c3" ] ]\n*/\n')),(0,o.kt)("p",null,'All of these examples work correctly in Rune because Rune essentially tracks the\n"source" of each update, and so it can know if two updates are correlated or\nnot. In this way, a rune is similar to a signal like in SolidJS, except that\nrunes can be asynchronous.'))}p.isMDXComponent=!0}}]);