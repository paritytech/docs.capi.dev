"use strict";(self.webpackChunkdocs_capi_dev_2=self.webpackChunkdocs_capi_dev_2||[]).push([[460],{3905:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>y});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=a.createContext({}),p=function(e){var n=a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},l=function(e){var n=p(e.components);return a.createElement(i.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=p(t),m=r,y=u["".concat(i,".").concat(m)]||u[m]||d[m]||o;return t?a.createElement(y,c(c({ref:n},l),{},{components:t})):a.createElement(y,c({ref:n},l))}));function y(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,c=new Array(o);c[0]=m;var s={};for(var i in n)hasOwnProperty.call(n,i)&&(s[i]=n[i]);s.originalType=e,s[u]="string"==typeof e?e:r,c[1]=s;for(var p=2;p<o;p++)c[p]=t[p];return a.createElement.apply(null,c)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3532:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=t(7462),r=(t(7294),t(3905));const o={},c="Types",s={unversionedId:"types",id:"types",title:"Types",description:"The types of the on-chain world are declared in a given",source:"@site/docs/types.md",sourceDirName:".",slug:"/types",permalink:"/types",draft:!1,editUrl:"https://github.com/paritytech/docs.capi.dev/tree/main/docs/types.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Extrinsics",permalink:"/basics/extrinsics"},next:{title:"Rune",permalink:"/rune/"}},i={},p=[{value:"Conversion Table",id:"conversion-table",level:2},{value:"Declarations",id:"declarations",level:2},{value:"Factories",id:"factories",level:2},{value:"Guards",id:"guards",level:2},{value:"Codecs",id:"codecs",level:2}],l={toc:p},u="wrapper";function d(e){let{components:n,...t}=e;return(0,r.kt)(u,(0,a.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"types"},"Types"),(0,r.kt)("p",null,"The types of the on-chain world are declared in a given\n",(0,r.kt)("a",{parentName:"p",href:"https://substrate.io/"},"Substrate"),"-based chain's (Rust) source code. While many\ntypes may remain consistent across chains, many may differ. On one chain,\n",(0,r.kt)("inlineCode",{parentName:"p"},"AccountData")," may be defined with fields describing fungible assets; on another\n(hypothetical) chain, perhaps ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountData")," describes non-fungible assets,\nreputation, linked accounts or something else entirely. Capi's codegen outputs\nTypeScript-idiomatic equivalents of the Rust-declared types, along with\nutilities such as object and variant factories, type guards and\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/subshape"},"shapes"),". This reduces the friction of\ntargeting a Rust-defined environment from your JavaScript environment. It also\nensures optimal type safety!"),(0,r.kt)("h2",{id:"conversion-table"},"Conversion Table"),(0,r.kt)("p",null,"The following table describes how Capi translates a given chain's Rust-declared\ntypes to and from JavaScript types."),(0,r.kt)("table",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("b",null,"Rust")),(0,r.kt)("td",null,(0,r.kt)("b",null,"TypeScript"))),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"type T0 = ();\ntype T1 = (A,);\ntype T2 = (A, B);\ntype T3 = Vec<u8>;\ntype T4 = [u8; N];\ntype T5 = Vec<A>;\ntype T6 = [A; N];\ntype T7 = Option<A>;\ntype T8 = Result<O, E>;\n\nstruct S0;\nstruct S1(A);\nstruct S2(A, B);\nstruct S3 { a: A }\n\nenum E0 {}\nenum E1 { A, B, C }\nenum E2 {\n  W,\n  X(A),\n  Y(B, C),\n  Z { d: D },\n}\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'type T0 = null\ntype T1 = A\ntype T2 = [A, B]\ntype T3 = Uint8Array\ntype T4 = Uint8Array\ntype T5 = A[]\ntype T6 = A[] & { length: N }\ntype T7 = A | undefined\ntype T8 = O | ChainError<E>\n\ntype S0 = null\ntype S1 = A\ntype S2 = [A, B]\ntype S3 = { a: A }\n\ntype E0 = never\ntype E1 = "A" | "B" | "C"\ntype E2 =\n  | { type: "W" }\n  | { type: "X"; value: A }\n  | { type: "Y"; value: [B, C] }\n  | { type: "Z"; d: D }\n\u200b\n'))))),(0,r.kt)("h2",{id:"declarations"},"Declarations"),(0,r.kt)("p",null,"After syncing (covered in ",(0,r.kt)("a",{parentName:"p",href:"/setup"},"the setup section"),"), we can access\ntype-related exports from the net-specific codegen."),(0,r.kt)("p",null,"Let's consider the example of Polkadot's ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountInfo")," type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { AccountInfo } from "@capi/polkadot"\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountInfo")," type has the following signature."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type AccountInfo = {\n  nonce: number\n  consumers: number\n  providers: number\n  sufficients: number\n  data: {\n    free: bigint\n    reserved: bigint\n    miscFrozen: bigint\n    feeFrozen: bigint\n  }\n}\n")),(0,r.kt)("p",null,"Rust enum variants' narrow representations are accessible from a namespace\noverlapping their union type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { XcmV1Junction } from "@capi/statemine"\n//       ^ a union, member of which is `XcmV1Junction.Parachain`\n\ntype Parachain = XcmV1Junction.Parachain\n')),(0,r.kt)("h2",{id:"factories"},"Factories"),(0,r.kt)("p",null,"Accompanying every object, tuple and union member type is a runtime factory for\nsimple construction of on-chain data types within JavaScript."),(0,r.kt)("p",null,"Let's use the ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountData")," example from earlier. We can utilize the very same\nimport as a factory with no change to our imports."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const accountData = AccountData({\n  nonce: 0,\n  consumers: 1,\n  providers: 2,\n  sufficients: 3,\n  data: {/* ... */},\n})\n")),(0,r.kt)("p",null,"In the case of a union variant, the factories take care of tagging the value."),(0,r.kt)("p",null,"Instead of writing the following..."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const J = {\n  type: "Parachain",\n  value: 1,\n}\n')),(0,r.kt)("p",null,"... we can do this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const J = XcmV1Junction.Parachain(1)\n")),(0,r.kt)("p",null,"These factories accept both resolved JS values and (unresolved) Runes (covered\nin ",(0,r.kt)("a",{parentName:"p",href:"/basics/rune_primer"},"a previous section"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const one = Rune.constant(1)\nconst J = XcmV1Junction.Parachain(one)\n")),(0,r.kt)("h2",{id:"guards"},"Guards"),(0,r.kt)("p",null,"Every union variant has an accompanying type guard. This helps us check for\nspecific variants, all the while narrowing the value for safer handling."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { RuntimeEvent } from "@capi/ink-chain"\n\nevent // `RuntimeEvent`\nif (RuntimeEvent.isContracts(event)) {\n  event // `RuntimeEvent.Contracts`\n}\n')),(0,r.kt)("h2",{id:"codecs"},"Codecs"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"$"),"-prefixed, camel-cased type name is actually a\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/subshape"},(0,r.kt)("inlineCode",{parentName:"a"},"subShape")),' "shape". This codec can be\nused for many use cases.'),(0,r.kt)("p",null,"For instance, we may want to perform runtime validation of some untrusted data."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { $accountInfo } from "@capi/polkadot"\nimport { $ } from "capi"\n\ntry {\n  $.assert($accountInfo, untrustedData)\n  untrustedData // `AccountInfo`\n  console.log("We know that `untrustedData` is of type `AccountInfo`")\n} catch (e) {\n  console.log("`untrustedData` is not of type `AccountInfo`")\n}\n')),(0,r.kt)("p",null,"Or, we may want to compose a new codec for our own use case, such as a tRPC\nresolver."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { $ } from "capi"\n\nconst $accountInfos = $.array($accountInfo)\n\nconst appRouter = t.router({\n  getAccountData: t.procedure\n    .input($accountInfos) // <--\n    .query((accountInfos) => {\n      // ...\n    }),\n})\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/subshape"},"shapes")," are supported natively\nby tRPC for typing and validation.")))}d.isMDXComponent=!0}}]);