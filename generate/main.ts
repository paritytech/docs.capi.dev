import * as fs from "https://deno.land/std@0.185.0/fs/mod.ts"
import * as path from "https://deno.land/std@0.185.0/path/mod.ts"
import { sentenceCase } from "https://deno.land/x/case@2.1.1/mod.ts"
import { description, title, toMarkdown } from "https://deno.land/x/egts@v0.1.0-beta.3/mod.ts"

const clonePath = new URL("capi", import.meta.url)
try {
  await Deno.remove(clonePath, { recursive: true })
  // deno-lint-ignore no-empty
} catch (_) {}
await Deno.mkdir(clonePath)
await new Deno.Command("git", {
  args: ["init"],
  cwd: clonePath,
}).output()
await new Deno.Command("git", {
  args: ["remote", "add", "-f", "origin", "git@github.com:paritytech/capi.git"],
  cwd: clonePath,
}).output()
await new Deno.Command("git", {
  args: ["config", "core.sparseCheckout", "true"],
  cwd: clonePath,
}).spawn().output()
await Deno.writeTextFile(path.join(clonePath.pathname, ".git/info/sparse-checkout"), "examples/")
await new Deno.Command("git", {
  args: ["pull", "origin", "main"],
  cwd: clonePath,
}).spawn().output()

const examplesDir = path.join(clonePath.pathname, "examples")
const pending: Promise<void>[] = []
const generated: string[] = []
const sidebarItems: Record<string, SidebarItem> = {}
for await (const walkEntry of fs.walk(examplesDir)) {
  if (walkEntry.isFile && walkEntry.path.endsWith(".eg.ts")) {
    const relativePathWithoutExt = path.relative(examplesDir, walkEntry.path).slice(0, -6)
    const dest = `docs/${relativePathWithoutExt}.md`
    const junctions = relativePathWithoutExt.split("/")
    if (junctions.length) {
      // TODO: use egts frontmatter title instead
      const label = sentenceCase(junctions[0]!)
      const sidebarItem = sidebarItems[label] ??= {
        type: "category",
        label,
        items: [],
      }
      // TODO: why does satisfies `{type: "category"}` not work?
      if (sidebarItem.type === "category") sidebarItem.items.push(relativePathWithoutExt)
    } else {
      const label = sentenceCase(relativePathWithoutExt)
      sidebarItems[label] = {
        type: "doc",
        id: relativePathWithoutExt,
      }
    }
    generated.push(dest)
    pending.push(compileEg(walkEntry.path, dest))
  }
}
await Promise.all(pending)
const ignoreContents = generated.map((v) => v.slice(5)).join("\n")
const exampleSidebarItemsFilename = "example_sidebar_items.json"
await Promise.all([
  Deno.writeTextFile(
    "docs/.gitignore",
    `# generated by \`generate/main.ts\`
${exampleSidebarItemsFilename}
${ignoreContents}
`,
  ),
  Deno.writeTextFile(
    `docs/${exampleSidebarItemsFilename}`,
    JSON.stringify(Object.values(sidebarItems), null, 2),
  ),
])

async function compileEg(pathname: string, dest: string) {
  const src = await Deno.readTextFile(pathname)
  const { frontmatter, content: contentRaw } = toMarkdown(pathname, src, {
    title,
    description,
  })
  const content = `<!-- generated by \`generate/main.ts\ -->
# ${frontmatter.title}

${frontmatter.description}

---

${contentRaw}`
  await fs.ensureFile(dest)
  await Deno.writeTextFile(dest, content)
}

type SidebarItem = {
  type: "doc"
  id: string
} | {
  type: "category"
  label: string
  items: string[]
}
