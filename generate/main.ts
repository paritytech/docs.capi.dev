import * as fs from "https://deno.land/std@0.185.0/fs/mod.ts"
import * as path from "https://deno.land/std@0.185.0/path/mod.ts"
import { description, title, toMarkdown } from "https://deno.land/x/egts@v0.1.0-beta.3/mod.ts"

const clonePath = new URL("capi", import.meta.url)
try {
  await Deno.remove(clonePath, { recursive: true })
  // deno-lint-ignore no-empty
} catch (_) {}
await Deno.mkdir(clonePath)
await new Deno.Command("git", {
  args: ["init"],
  cwd: clonePath,
}).output()
await new Deno.Command("git", {
  args: ["remote", "add", "-f", "origin", "git@github.com:paritytech/capi.git"],
  cwd: clonePath,
}).output()
await new Deno.Command("git", {
  args: ["config", "core.sparseCheckout", "true"],
  cwd: clonePath,
}).spawn().output()
await Deno.writeTextFile(path.join(clonePath.pathname, ".git/info/sparse-checkout"), "examples/")
await new Deno.Command("git", {
  args: ["pull", "origin", "main"],
  cwd: clonePath,
}).spawn().output()

const examplesDir = path.join(clonePath.pathname, "examples")
const pending: Promise<void>[] = []
const generated: string[] = []
for await (const walkEntry of fs.walk(examplesDir)) {
  if (walkEntry.isFile && walkEntry.path.endsWith(".eg.ts")) {
    pending.push(compileEg(path.relative(examplesDir, walkEntry.path).slice(0, -6), walkEntry.path))
  }
}
await Promise.all(pending)
const ignoreContents = generated.map((v) => v.slice(5)).join("\n")
await Deno.writeTextFile(
  "docs/.gitignore",
  `# generated by \`generate/main.ts\`
${ignoreContents}
`,
)

async function compileEg(egName: string, pathname: string) {
  const src = await Deno.readTextFile(pathname)
  const { frontmatter, content: contentRaw } = toMarkdown(pathname, src, {
    title,
    description,
  })
  const content = `#${frontmatter.title}

${frontmatter.description}

---

${contentRaw}`
  const dest = `docs/${egName}.md`
  await fs.ensureFile(dest)
  await Deno.writeTextFile(dest, content)
  generated.push(dest)
}
